
<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Watermark Adder</title>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background: #f4f4f4;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .upload-section {
            margin-bottom: 30px;
            text-align: center;
        }
        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            margin-bottom: 20px;
        }
        .upload-area:hover, .upload-area.dragover {
            border-color: #dc143c;
            background: #fff5f5;
        }
        .upload-area input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        .upload-icon {
            font-size: 48px;
            color: #ddd;
            margin-bottom: 15px;
        }
        .upload-text {
            font-size: 18px;
            color: #666;
            margin-bottom: 10px;
        }
        .upload-subtext {
            font-size: 14px;
            color: #999;
        }
        .file-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: none;
        }
        .file-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .file-name {
            font-weight: 600;
            color: #333;
        }
        .file-stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #666;
        }
        .watermark-options {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        .option-group {
            margin-bottom: 20px;
        }
        .option-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }
        .option-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        .control-group select, .control-group input {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .control-group select:focus, .control-group input:focus {
            outline: none;
            border-color: #dc143c;
        }
        .color-picker {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .color-input {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .watermark-type-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        .type-btn {
            background: #e9ecef;
            border: 2px solid #ddd;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .type-btn.active {
            background: #dc143c;
            color: white;
            border-color: #dc143c;
        }
        .type-btn:hover {
            border-color: #dc143c;
        }
        .text-options, .image-options {
            display: none;
        }
        .text-options.active, .image-options.active {
            display: block;
        }
        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border: 2px solid #ddd;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }
        .preview-section {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .preview-title {
            font-weight: 600;
            color: #333;
        }
        .preview-canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f8f9fa;
            display: block;
            margin: 0 auto;
        }
        .add-btn {
            background: #dc143c;
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
        }
        .add-btn:hover {
            background: #b22222;
            transform: scale(1.05);
        }
        .add-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .progress-container {
            margin-top: 20px;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc143c, #ff6b6b);
            width: 0%;
            transition: width 0.3s ease;
        }
        .download-section {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        .download-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
        }
        .download-btn {
            background: #28a745;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .download-btn:hover {
            background: #218838;
            transform: scale(1.05);
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #b3d7ff;
        }
        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        .position-btn {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        .position-btn.active {
            background: #dc143c;
            color: white;
            border-color: #dc143c;
        }
        .position-btn:hover {
            border-color: #dc143c;
        }
        .examples-section {
            background: #e9ecef;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        .examples-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }
        .example-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px;
        }
        .example-btn {
            background: white;
            border: 1px solid #ddd;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            transition: all 0.3s ease;
        }
        .example-btn:hover {
            background: #f8f9fa;
            border-color: #dc143c;
        }
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            .upload-area {
                padding: 30px 20px;
            }
            .option-controls {
                grid-template-columns: 1fr;
            }
            .file-details {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            .action-buttons {
                flex-direction: column;
                align-items: center;
            }
            .watermark-type-selector {
                flex-direction: column;
                align-items: stretch;
            }
            .position-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíß PDF Watermark Adder</h1>

        <div class="examples-section">
            <div class="examples-title">Common Watermark Types:</div>
            <div class="example-types">
                <button class="example-btn" onclick="applyExample('confidential')">üîí Confidential<br><small>Security watermark</small></button>
                <button class="example-btn" onclick="applyExample('draft')">üìù Draft<br><small>Document status</small></button>
                <button class="example-btn" onclick="applyExample('company')">üè¢ Company Logo<br><small>Branding</small></button>
                <button class="example-btn" onclick="applyExample('copyright')">¬© Copyright<br><small>Legal protection</small></button>
                <button class="example-btn" onclick="applyExample('sample')">üéØ Sample<br><small>Preview document</small></button>
                <button class="example-btn" onclick="applyExample('date')">üìÖ Date Stamp<br><small>Time-sensitive</small></button>
                <button class="example-btn" onclick="applyExample('diagonal')">‚ÜòÔ∏è Diagonal<br><small>Classic style</small></button>
                <button class="example-btn" onclick="applyExample('signature')">‚úçÔ∏è Digital Signature<br><small>Authentication</small></button>
            </div>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <input type="file" id="pdfFile" accept=".pdf">
                <div class="upload-icon">üìÑ</div>
                <div class="upload-text">Drop PDF file here or click to browse</div>
                <div class="upload-subtext">Supports PDF files up to 10MB</div>
            </div>
        </div>

        <div class="file-info" id="fileInfo">
            <div class="file-details">
                <div class="file-name" id="fileName"></div>
                <div class="file-stats">
                    <span id="fileSize"></span>
                    <span id="pageCount"></span>
                </div>
            </div>
        </div>

        <div class="watermark-options" id="watermarkOptions" style="display: none;">
            <div class="watermark-type-selector">
                <button class="type-btn active" onclick="switchWatermarkType('text')">
                    <i class="fas fa-font"></i> Text Watermark
                </button>
                <button class="type-btn" onclick="switchWatermarkType('image')">
                    <i class="fas fa-image"></i> Image Watermark
                </button>
            </div>

            <div class="text-options active" id="textOptions">
                <div class="option-group">
                    <h3>Text Settings</h3>
                    <div class="option-controls">
                        <div class="control-group">
                            <label for="watermarkText">Watermark Text</label>
                            <input type="text" id="watermarkText" placeholder="Enter watermark text" value="CONFIDENTIAL">
                        </div>
                        <div class="control-group">
                            <label for="fontSize">Font Size</label>
                            <select id="fontSize">
                                <option value="24">Small (24pt)</option>
                                <option value="36" selected>Medium (36pt)</option>
                                <option value="48">Large (48pt)</option>
                                <option value="60">Extra Large (60pt)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="fontFamily">Font Family</label>
                            <select id="fontFamily">
                                <option value="Helvetica" selected>Helvetica</option>
                                <option value="Arial">Arial</option>
                                <option value="Times-Roman">Times New Roman</option>
                                <option value="Courier">Courier</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="opacity">Opacity</label>
                            <select id="opacity">
                                <option value="0.1">10% (Subtle)</option>
                                <option value="0.2">20%</option>
                                <option value="0.3" selected>30%</option>
                                <option value="0.4">40%</option>
                                <option value="0.5">50% (Balanced)</option>
                                <option value="0.6">60%</option>
                                <option value="0.7">70%</option>
                                <option value="0.8">80% (Bold)</option>
                                <option value="0.9">90%</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Text Color</label>
                            <div class="color-picker">
                                <input type="color" id="textColor" value="#666666" class="color-input">
                                <input type="text" id="colorHex" value="#666666" readonly style="width: 80px;">
                            </div>
                        </div>
                        <div class="control-group">
                            <label for="rotation">Rotation (degrees)</label>
                            <input type="number" id="rotation" value="45" min="-180" max="180" step="5">
                        </div>
                    </div>
                </div>

                <div class="option-group">
                    <h3>Text Effects</h3>
                    <div class="option-controls">
                        <div class="control-group">
                            <label for="bold">Style</label>
                            <select id="bold">
                                <option value="normal" selected>Normal</option>
                                <option value="bold">Bold</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="outline">Outline</label>
                            <select id="outline">
                                <option value="none" selected>No Outline</option>
                                <option value="thin">Thin Outline</option>
                                <option value="thick">Thick Outline</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="repeat">Repeat Pattern</label>
                            <select id="repeat">
                                <option value="single" selected>Single</option>
                                <option value="tiled">Tiled</option>
                                <option value="diagonal">Diagonal Line</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div class="image-options" id="imageOptions">
                <div class="option-group">
                    <h3>Image Settings</h3>
                    <div class="option-controls">
                        <div class="control-group">
                            <label for="watermarkImage">Watermark Image</label>
                            <input type="file" id="watermarkImage" accept="image/*">
                            <img id="imagePreview" class="image-preview" alt="Watermark preview">
                        </div>
                        <div class="control-group">
                            <label for="imageScale">Scale (%)</label>
                            <input type="number" id="imageScale" value="50" min="10" max="200" step="5">
                        </div>
                        <div class="control-group">
                            <label for="imageOpacity">Opacity</label>
                            <select id="imageOpacity">
                                <option value="0.1">10% (Subtle)</option>
                                <option value="0.2">20%</option>
                                <option value="0.3" selected>30%</option>
                                <option value="0.4">40%</option>
                                <option value="0.5">50% (Balanced)</option>
                                <option value="0.6">60%</option>
                                <option value="0.7">70%</option>
                                <option value="0.8">80% (Bold)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="imageRotation">Rotation (degrees)</label>
                            <input type="number" id="imageRotation" value="0" min="-180" max="180" step="5">
                        </div>
                    </div>
                </div>
            </div>

            <div class="option-group">
                <h3>Position Settings</h3>
                <div class="option-controls">
                    <div class="control-group">
                        <label for="position">Position</label>
                        <select id="position">
                            <option value="center" selected>Center</option>
                            <option value="top-left">Top Left</option>
                            <option value="top-center">Top Center</option>
                            <option value="top-right">Top Right</option>
                            <option value="middle-left">Middle Left</option>
                            <option value="middle-right">Middle Right</option>
                            <option value="bottom-left">Bottom Left</option>
                            <option value="bottom-center">Bottom Center</option>
                            <option value="bottom-right">Bottom Right</option>
                            <option value="custom">Custom Position</option>
                        </select>
                    </div>
                    <div class="control-group" id="customXGroup" style="display: none;">
                        <label for="customX">X Position (%)</label>
                        <input type="number" id="customX" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="control-group" id="customYGroup" style="display: none;">
                        <label for="customY">Y Position (%)</label>
                        <input type="number" id="customY" value="50" min="0" max="100" step="1">
                    </div>
                    <div class="control-group">
                        <label for="pages">Apply to Pages</label>
                        <select id="pages">
                            <option value="all" selected>All Pages</option>
                            <option value="first">First Page Only</option>
                            <option value="last">Last Page Only</option>
                            <option value="even">Even Pages Only</option>
                            <option value="odd">Odd Pages Only</option>
                            <option value="custom">Custom Range</option>
                        </select>
                    </div>
                    <div class="control-group" id="pageRangeGroup" style="display: none;">
                        <label for="pageRange">Page Range (e.g., 1-3,5,7-9)</label>
                        <input type="text" id="pageRange" placeholder="1-3,5,7-9">
                    </div>
                </div>
            </div>
        </div>

        <div class="preview-section" id="previewSection">
            <div class="preview-header">
                <div class="preview-title">Watermark Preview (Page 1)</div>
                <div>Click "Add Watermark" to apply to all selected pages</div>
            </div>
            <canvas id="previewCanvas" class="preview-canvas"></canvas>
        </div>

        <button class="add-btn" id="addBtn" onclick="addWatermark()">üíß Add Watermark</button>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div style="text-align: center; margin-top: 10px; color: #666;" id="progressText">Adding watermark to PDF...</div>
        </div>

        <div class="download-section" id="downloadSection">
            <div class="download-title">Watermark Added Successfully!</div>
            <div style="margin-bottom: 20px; color: #666;" id="conversionStats">Your watermarked PDF is ready for download</div>
            <div class="action-buttons">
                <button class="download-btn" onclick="downloadPDF()">üíæ Download PDF</button>
            </div>
        </div>

        <div class="status" id="status"></div>
    </div>

    <script>
        let pdfDoc = null;
        let watermarkImage = null;
        let currentWatermarkType = 'text';

        // DOM elements
        const pdfFile = document.getElementById('pdfFile');
        const uploadArea = document.getElementById('uploadArea');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const pageCount = document.getElementById('pageCount');
        const watermarkOptions = document.getElementById('watermarkOptions');
        const previewSection = document.getElementById('previewSection');
        const previewCanvas = document.getElementById('previewCanvas');
        const addBtn = document.getElementById('addBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const downloadSection = document.getElementById('downloadSection');
        const conversionStats = document.getElementById('conversionStats');
        const statusDiv = document.getElementById('status');
        const watermarkImageInput = document.getElementById('watermarkImage');
        const imagePreview = document.getElementById('imagePreview');
        const textColor = document.getElementById('textColor');
        const colorHex = document.getElementById('colorHex');

        // Event listeners
        pdfFile.addEventListener('change', handleFileSelect);
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleFileDrop);
        watermarkImageInput.addEventListener('change', handleImageSelect);
        textColor.addEventListener('input', updateColorHex);
        document.getElementById('position').addEventListener('change', handlePositionChange);
        document.getElementById('pages').addEventListener('change', handlePagesChange);

        function applyExample(type) {
            const examples = {
                confidential: { text: 'CONFIDENTIAL', color: '#ff0000', opacity: '0.3', rotation: '45' },
                draft: { text: 'DRAFT', color: '#ffa500', opacity: '0.4', rotation: '0' },
                company: { text: 'COMPANY LOGO', color: '#000080', opacity: '0.2', rotation: '0' },
                copyright: { text: '¬© 2024 All Rights Reserved', color: '#666666', opacity: '0.3', rotation: '0' },
                sample: { text: 'SAMPLE', color: '#008000', opacity: '0.4', rotation: '30' },
                date: { text: new Date().toLocaleDateString(), color: '#000000', opacity: '0.5', rotation: '0' },
                diagonal: { text: 'WATERMARK', color: '#cccccc', opacity: '0.2', rotation: '45' },
                signature: { text: 'APPROVED', color: '#0000ff', opacity: '0.4', rotation: '0' }
            };

            const example = examples[type];
            if (example) {
                document.getElementById('watermarkText').value = example.text;
                document.getElementById('textColor').value = example.color;
                document.getElementById('colorHex').value = example.color;
                document.getElementById('opacity').value = example.opacity;
                document.getElementById('rotation').value = example.rotation;

                switchWatermarkType('text');
                updatePreview();
                showStatus(`Applied ${type} watermark example!`, 'info');
            }
        }

        function switchWatermarkType(type) {
            currentWatermarkType = type;

            document.querySelectorAll('.type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            document.querySelectorAll('.text-options, .image-options').forEach(el => {
                el.classList.remove('active');
            });

            if (type === 'text') {
                document.getElementById('textOptions').classList.add('active');
            } else {
                document.getElementById('imageOptions').classList.add('active');
            }

            updatePreview();
        }

        function updateColorHex() {
            colorHex.value = textColor.value;
            updatePreview();
        }

        function handlePositionChange() {
            const position = document.getElementById('position').value;
            const customXGroup = document.getElementById('customXGroup');
            const customYGroup = document.getElementById('customYGroup');

            if (position === 'custom') {
                customXGroup.style.display = 'block';
                customYGroup.style.display = 'block';
            } else {
                customXGroup.style.display = 'none';
                customYGroup.style.display = 'none';
            }

            updatePreview();
        }

        function handlePagesChange() {
            const pages = document.getElementById('pages').value;
            const pageRangeGroup = document.getElementById('pageRangeGroup');

            if (pages === 'custom') {
                pageRangeGroup.style.display = 'block';
            } else {
                pageRangeGroup.style.display = 'none';
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                if (file.size > 10 * 1024 * 1024) {
                    showStatus('PDF file size must be under 10MB. Please choose a smaller file.', 'error');
                    return;
                }
                processPDF(file);
            } else {
                showStatus('Please select a valid PDF file.', 'error');
            }
        }

        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    watermarkImage = new Image();
                    watermarkImage.onload = function() {
                        imagePreview.src = e.target.result;
                        imagePreview.style.display = 'block';
                        updatePreview();
                    };
                    watermarkImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else {
                showStatus('Please select a valid image file.', 'error');
            }
        }

        function handleDragOver(event) {
            event.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            uploadArea.classList.remove('dragover');
        }

        function handleFileDrop(event) {
            event.preventDefault();
            uploadArea.classList.remove('dragover');

            const file = event.dataTransfer.files[0];
            if (file && file.type === 'application/pdf') {
                if (file.size > 10 * 1024 * 1024) {
                    showStatus('PDF file size must be under 10MB. Please choose a smaller file.', 'error');
                    return;
                }
                processPDF(file);
                pdfFile.files = event.dataTransfer.files;
            } else {
                showStatus('Please drop a valid PDF file.', 'error');
            }
        }

        async function processPDF(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);

                const pages = pdfDoc.getPages();

                // Update UI
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                pageCount.textContent = `${pages.length} pages`;
                fileInfo.style.display = 'block';
                watermarkOptions.style.display = 'block';

                // Generate preview
                await updatePreview();

                showStatus(`PDF "${file.name}" loaded successfully. Configure your watermark settings.`, 'success');

            } catch (error) {
                console.error('PDF processing error:', error);
                showStatus('Error loading PDF: ' + error.message, 'error');
            }
        }

        async function updatePreview() {
            if (!pdfDoc) return;

            try {
                // Render first page for preview
                const firstPage = pdfDoc.getPages()[0];
                const { width, height } = firstPage.getSize();

                // Set canvas size (scale down for preview)
                const scale = Math.min(800 / width, 600 / height);
                previewCanvas.width = width * scale;
                previewCanvas.height = height * scale;

                const ctx = previewCanvas.getContext('2d');
                ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

                // Draw white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

                // Add watermark preview
                drawWatermarkPreview(ctx, width * scale, height * scale, scale);

                // Add subtle page border
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, previewCanvas.width, previewCanvas.height);

                previewSection.style.display = 'block';

            } catch (error) {
                console.error('Preview error:', error);
            }
        }

        function drawWatermarkPreview(ctx, canvasWidth, canvasHeight, scale) {
            if (currentWatermarkType === 'text') {
                const text = document.getElementById('watermarkText').value || 'WATERMARK';
                const fontSize = parseInt(document.getElementById('fontSize').value) * scale;
                const fontFamily = document.getElementById('fontFamily').value;
                const opacity = parseFloat(document.getElementById('opacity').value);
                const color = textColor.value;
                const rotation = parseInt(document.getElementById('rotation').value);
                const bold = document.getElementById('bold').value;
                const outline = document.getElementById('outline').value;
                const repeat = document.getElementById('repeat').value;

                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.fillStyle = color;
                ctx.font = `${bold === 'bold' ? 'bold ' : ''}${fontSize}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Calculate position
                const pos = getPosition(canvasWidth, canvasHeight);

                if (repeat === 'single') {
                    // Single watermark
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate((rotation * Math.PI) / 180);
                    drawText(ctx, text, 0, 0, outline, fontSize);
                } else if (repeat === 'tiled') {
                    // Tiled pattern
                    const spacing = fontSize * 3;
                    for (let x = spacing; x < canvasWidth; x += spacing) {
                        for (let y = spacing; y < canvasHeight; y += spacing) {
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.rotate((rotation * Math.PI) / 180);
                            drawText(ctx, text, 0, 0, outline, fontSize);
                            ctx.restore();
                        }
                    }
                } else if (repeat === 'diagonal') {
                    // Diagonal line
                    const spacing = fontSize * 2;
                    for (let i = -canvasWidth; i < canvasWidth + canvasHeight; i += spacing) {
                        const x = i;
                        const y = i * 0.5;
                        if (x >= 0 && x < canvasWidth && y >= 0 && y < canvasHeight) {
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.rotate((rotation * Math.PI) / 180);
                            drawText(ctx, text, 0, 0, outline, fontSize);
                            ctx.restore();
                        }
                    }
                }

                ctx.restore();

            } else if (currentWatermarkType === 'image' && watermarkImage) {
                const scalePercent = parseInt(document.getElementById('imageScale').value) / 100;
                const opacity = parseFloat(document.getElementById('imageOpacity').value);
                const rotation = parseInt(document.getElementById('imageRotation').value);

                const imgWidth = watermarkImage.width * scalePercent * scale;
                const imgHeight = watermarkImage.height * scalePercent * scale;

                const pos = getPosition(canvasWidth, canvasHeight);
                const x = pos.x - imgWidth / 2;
                const y = pos.y - imgHeight / 2;

                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.translate(pos.x, pos.y);
                ctx.rotate((rotation * Math.PI) / 180);
                ctx.drawImage(watermarkImage, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
                ctx.restore();
            }
        }

        function drawText(ctx, text, x, y, outline, fontSize) {
            if (outline !== 'none') {
                const outlineWidth = outline === 'thick' ? 2 : 1;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = outlineWidth;
                ctx.strokeText(text, x, y);
            }
            ctx.fillText(text, x, y);
        }

        function getPosition(canvasWidth, canvasHeight) {
            const position = document.getElementById('position').value;

            switch (position) {
                case 'center':
                    return { x: canvasWidth / 2, y: canvasHeight / 2 };
                case 'top-left':
                    return { x: canvasWidth * 0.2, y: canvasHeight * 0.2 };
                case 'top-center':
                    return { x: canvasWidth / 2, y: canvasHeight * 0.2 };
                case 'top-right':
                    return { x: canvasWidth * 0.8, y: canvasHeight * 0.2 };
                case 'middle-left':
                    return { x: canvasWidth * 0.2, y: canvasHeight / 2 };
                case 'middle-right':
                    return { x: canvasWidth * 0.8, y: canvasHeight / 2 };
                case 'bottom-left':
                    return { x: canvasWidth * 0.2, y: canvasHeight * 0.8 };
                case 'bottom-center':
                    return { x: canvasWidth / 2, y: canvasHeight * 0.8 };
                case 'bottom-right':
                    return { x: canvasWidth * 0.8, y: canvasHeight * 0.8 };
                case 'custom':
                    const customX = parseInt(document.getElementById('customX').value) / 100;
                    const customY = parseInt(document.getElementById('customY').value) / 100;
                    return { x: canvasWidth * customX, y: canvasHeight * customY };
                default:
                    return { x: canvasWidth / 2, y: canvasHeight / 2 };
            }
        }

        async function addWatermark() {
            if (!pdfDoc) {
                showStatus('Please load a PDF file first.', 'error');
                return;
            }

            // Show processing
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            addBtn.disabled = true;
            addBtn.textContent = 'üîÑ Adding Watermark...';
            downloadSection.style.display = 'none';

            try {
                const pages = pdfDoc.getPages();
                const totalPages = pages.length;

                // Determine which pages to process
                const pagesToProcess = getPagesToProcess(totalPages);

                progressFill.style.width = '10%';
                progressText.textContent = 'Preparing watermark...';

                for (let i = 0; i < pagesToProcess.length; i++) {
                    const pageIndex = pagesToProcess[i] - 1; // Convert to 0-based
                    const page = pages[pageIndex];

                    await addWatermarkToPage(page, pageIndex + 1);

                    const progress = 10 + (i / pagesToProcess.length) * 80;
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `Processing page ${i + 1} of ${pagesToProcess.length}...`;
                }

                progressFill.style.width = '95%';
                progressText.textContent = 'Finalizing PDF...';

                // Generate the modified PDF
                const pdfBytes = await pdfDoc.save();

                progressFill.style.width = '100%';
                progressText.textContent = 'Watermark addition complete!';

                setTimeout(() => {
                    displayDownload(pdfBytes, pagesToProcess.length);
                    progressContainer.style.display = 'none';
                    addBtn.disabled = false;
                    addBtn.textContent = 'üíß Add Watermark';
                }, 500);

            } catch (error) {
                console.error('Watermark addition error:', error);
                progressContainer.style.display = 'none';
                showStatus('Error adding watermark: ' + error.message, 'error');
                addBtn.disabled = false;
                addBtn.textContent = 'üíß Add Watermark';
            }
        }

        function getPagesToProcess(totalPages) {
            const pagesSetting = document.getElementById('pages').value;

            switch (pagesSetting) {
                case 'all':
                    return Array.from({ length: totalPages }, (_, i) => i + 1);
                case 'first':
                    return [1];
                case 'last':
                    return [totalPages];
                case 'even':
                    return Array.from({ length: Math.floor(totalPages / 2) }, (_, i) => (i + 1) * 2);
                case 'odd':
                    return Array.from({ length: Math.ceil(totalPages / 2) }, (_, i) => i * 2 + 1);
                case 'custom':
                    const range = document.getElementById('pageRange').value;
                    return parsePageRange(range, totalPages);
                default:
                    return Array.from({ length: totalPages }, (_, i) => i + 1);
            }
        }

        function parsePageRange(range, totalPages) {
            const pages = new Set();

            if (!range.trim()) return Array.from({ length: totalPages }, (_, i) => i + 1);

            const parts = range.split(',');
            for (const part of parts) {
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(n => parseInt(n.trim()));
                    for (let i = Math.max(1, start); i <= Math.min(totalPages, end); i++) {
                        pages.add(i);
                    }
                } else {
                    const page = parseInt(part.trim());
                    if (page >= 1 && page <= totalPages) {
                        pages.add(page);
                    }
                }
            }

            return Array.from(pages).sort((a, b) => a - b);
        }

        async function addWatermarkToPage(page, pageNumber) {
            if (currentWatermarkType === 'text') {
                await addTextWatermarkToPage(page, pageNumber);
            } else if (currentWatermarkType === 'image') {
                await addImageWatermarkToPage(page, pageNumber);
            }
        }

        async function addTextWatermarkToPage(page, pageNumber) {
            const text = document.getElementById('watermarkText').value || 'WATERMARK';
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const fontFamily = document.getElementById('fontFamily').value;
            const opacity = parseFloat(document.getElementById('opacity').value);
            const color = textColor.value;
            const rotation = parseInt(document.getElementById('rotation').value);
            const bold = document.getElementById('bold').value;
            const repeat = document.getElementById('repeat').value;

            const { width, height } = page.getSize();

            // Create appearance stream for text watermark
            const font = await pdfDoc.embedFont(PDFLib.StandardFonts[fontFamily] || PDFLib.StandardFonts.Helvetica);

            const appearance = pdfDoc.createFormXObject();

            // Calculate position
            const pos = getAbsolutePosition(page, fontSize);

            if (repeat === 'single') {
                // Single watermark
                page.drawText(text, {
                    x: pos.x,
                    y: pos.y,
                    size: fontSize,
                    font: font,
                    color: PDFLib.rgb(
                        parseInt(color.slice(1, 3), 16) / 255,
                        parseInt(color.slice(3, 5), 16) / 255,
                        parseInt(color.slice(5, 7), 16) / 255
                    ),
                    rotate: PDFLib.degrees(rotation),
                    opacity: opacity
                });
            } else {
                // For tiled or diagonal patterns, we'd need multiple drawText calls
                // This is a simplified implementation - in a full version, you'd repeat the text
                page.drawText(text, {
                    x: pos.x,
                    y: pos.y,
                    size: fontSize,
                    font: font,
                    color: PDFLib.rgb(
                        parseInt(color.slice(1, 3), 16) / 255,
                        parseInt(color.slice(3, 5), 16) / 255,
                        parseInt(color.slice(5, 7), 16) / 255
                    ),
                    rotate: PDFLib.degrees(rotation),
                    opacity: opacity
                });
            }
        }

        async function addImageWatermarkToPage(page, pageNumber) {
            if (!watermarkImage) return;

            const scalePercent = parseInt(document.getElementById('imageScale').value) / 100;
            const opacity = parseFloat(document.getElementById('imageOpacity').value);
            const rotation = parseInt(document.getElementById('imageRotation').value);

            // Convert image to PDF image
            const imageBytes = await fetch(watermarkImage.src).then(res => res.arrayBuffer());
            const image = await pdfDoc.embedPng(imageBytes); // Assuming PNG, could detect format

            const { width, height } = page.getSize();
            const imgWidth = (image.width * scalePercent);
            const imgHeight = (image.height * scalePercent);

            // Calculate position
            const pos = getAbsolutePosition(page, Math.max(imgWidth, imgHeight));

            page.drawImage(image, {
                x: pos.x - imgWidth / 2,
                y: pos.y - imgHeight / 2,
                width: imgWidth,
                height: imgHeight,
                rotate: PDFLib.degrees(rotation),
                opacity: opacity
            });
        }

        function getAbsolutePosition(page, elementSize) {
            const { width, height } = page.getSize();
            const position = document.getElementById('position').value;

            switch (position) {
                case 'center':
                    return { x: width / 2, y: height / 2 };
                case 'top-left':
                    return { x: width * 0.2, y: height * 0.8 };
                case 'top-center':
                    return { x: width / 2, y: height * 0.8 };
                case 'top-right':
                    return { x: width * 0.8, y: height * 0.8 };
                case 'middle-left':
                    return { x: width * 0.2, y: height / 2 };
                case 'middle-right':
                    return { x: width * 0.8, y: height / 2 };
                case 'bottom-left':
                    return { x: width * 0.2, y: height * 0.2 };
                case 'bottom-center':
                    return { x: width / 2, y: height * 0.2 };
                case 'bottom-right':
                    return { x: width * 0.8, y: height * 0.2 };
                case 'custom':
                    const customX = parseInt(document.getElementById('customX').value) / 100;
                    const customY = parseInt(document.getElementById('customY').value) / 100;
                    return { x: width * customX, y: height * customY };
                default:
                    return { x: width / 2, y: height / 2 };
            }
        }

        function displayDownload(pdfBytes, pagesProcessed) {
            // Create download link
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);

            // Create temporary link for download
            const a = document.createElement('a');
            a.href = url;
            a.download = 'watermarked_document.pdf';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            conversionStats.textContent = `Watermark successfully added to ${pagesProcessed} page${pagesProcessed > 1 ? 's' : ''}`;
            downloadSection.style.display = 'block';
            showStatus(`‚úÖ Watermark added to ${pagesProcessed} pages successfully!`, 'success');
        }

        function downloadPDF() {
            // The download is already triggered in displayDownload
            // This function can be used for additional download options if needed
            showStatus('PDF downloaded successfully!', 'success');
        }

        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';

            // Keep error messages visible longer
            if (type === 'error') {
                setTimeout(() => {
                    if (statusDiv.classList.contains('error')) {
                        statusDiv.style.display = 'none';
                    }
                }, 8000);
            } else {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Add event listeners for input changes to update preview
        document.querySelectorAll('input, select').forEach(element => {
            element.addEventListener('input', updatePreview);
            element.addEventListener('change', updatePreview);
        });

        pdfFile.addEventListener('click', function() {
            this.value = '';
        });
    </script>
</body>
</html>